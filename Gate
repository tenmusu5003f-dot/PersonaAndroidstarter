{
  "appName": "Persona",
  "minLogLevel": "INFO",
  "cache": { "memoryLimit": 16, "diskEnabled": true },
  "features": {
    "useCompose": true,
    "bgmEnabled": false,
    "telemetry": false
  }
}

{
  "assets": [
    "config.json",
    "personas.json",
    "media/aria.png",
    "media/hermes.png",
    "media/nox.png",
    "media/echo.png",
    "media/home_01.mp3"
  ]
}

{
  "algorithm": "SHA-256",
  "strict": true,
  "files": {
    "config.json": "TOFU",
    "personas.json": "TOFU",
    "media/aria.png": "TOFU",
    "media/hermes.png": "TOFU",
    "media/nox.png": "TOFU",
    "media/echo.png": "TOFU",
    "media/home_01.mp3": "TOFU"
  }
}

{
  "blockOnMismatch": true,
  "logLevel": "WARN",
  "telemetry": false,
  "keystoreAlias": "persona_app_key"
}

// ===== セキュリティ層（専用フォルダ） ==========================
import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import androidx.security.crypto.EncryptedSharedPreferences
import androidx.security.crypto.MasterKey
import java.security.MessageDigest

object Vault {
    private lateinit var prefs: SharedPreferences
    private lateinit var masterKey: MasterKey
    private var allow: Set<String> = emptySet()
    private var sums: JSONObject = JSONObject()
    private var policy: JSONObject = JSONObject()

    fun boot(ctx: Context) {
        // EncryptedSharedPreferences（ゼロ円で使える公式）
        masterKey = MasterKey.Builder(ctx)
            .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
            .build()
        prefs = EncryptedSharedPreferences.create(
            ctx, "persona_sec",
            masterKey,
            EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
            EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
        )
        allow = JSONObject(readAsset(ctx, "security/allowlist.json"))
            .getJSONArray("assets").toList().toSet()
        sums = JSONObject(readAsset(ctx, "security/checksums.json"))
        policy = JSONObject(readAsset(ctx, "security/policy.json"))
    }

    fun verifyAll(ctx: Context, extraPaths: List<String> = emptyList()) {
        val algo = sums.getString("algorithm")
        val strict = sums.optBoolean("strict", true)
        val files = (sums.getJSONObject("files").toMap()).toMutableMap()

        // 追加（personas.json内で参照されるmediaなど）
        extraPaths.forEach { files.putIfAbsent(it, "TOFU") }

        files.forEach { (path, expected) ->
            require(allow.contains(path)) { "Asset not allowed: $path" }
            val actual = sha256(ctx, path, algo)
            val key = "sha:$path"

            val stored = prefs.getString(key, null)
            val verdict = when {
                expected == "TOFU" && stored == null -> {
                    prefs.edit().putString(key, actual).apply(); "INIT"
                }
                stored != null && stored == actual -> "OK"
                expected != "TOFU" && expected.equals(actual, ignoreCase = true) -> "OK"
                else -> "FAIL"
            }
            if (verdict == "FAIL" && policy.optBoolean("blockOnMismatch", true)) {
                throw SecurityException("Integrity mismatch: $path")
            }
        }
    }

    private fun sha256(ctx: Context, path: String, algo: String): String {
        val md = MessageDigest.getInstance("SHA-256")
        ctx.assets.open(path).use { inp ->
            val buf = ByteArray(8192)
            while (true) {
                val n = inp.read(buf)
                if (n <= 0) break
                md.update(buf, 0, n)
            }
        }
        return md.digest().joinToString("") { "%02x".format(it) }
    }

    private fun readAsset(ctx: Context, path: String): String =
        ctx.assets.open(path).bufferedReader().use(BufferedReader::readText)
}

object Gate {
    // ...
    fun boot(ctx: Context) {
        if (booted) return
        Vault.boot(ctx)                       // ★ 追加
        cfg = JSONObject(readAsset(ctx, "config.json"))
        booted = true
    }
}

object Personas {
    // ...
    fun ensure(ctx: Context) {
        if (loaded) return
        require(Gate.isOpen()) { "Gate closed" }

        // personas.json → 先に整合性検証
        Vault.verifyAll(ctx, extraPaths = emptyList())

        val root = JSONObject(readAsset(ctx, ASSET))
        val arr = root.getJSONArray("personas")
        val extra = mutableListOf<String>()
        for (i in 0 until arr.length()) {
            val o = arr.getJSONObject(i)
            val style = o.getJSONObject("style")
            val theme = o.optJSONObject("theme")
            val prompts = o.optJSONObject("prompts") ?: JSONObject()
            list += Persona(
                id = o.getString("id"),
                displayName = o.getString("displayName"),
                role = o.getString("role"),
                tone = style.getString("tone"),
                formality = style.getString("formality"),
                capabilities = o.getJSONArray("capabilities").toList(),
                color = theme?.optString("color"),
                icon = theme?.optString("icon"),
                bgm = theme?.optString("bgm"),
                prompts = prompts.toMap()
            )
            theme?.optString("icon")?.let { extra += it }
            theme?.optString("bgm")?.let { extra += it }
        }

        // メディアも含めてTOFU検証（初回固定 → 次回以降改変検知）
        Vault.verifyAll(ctx, extraPaths = extra)

        loaded = true
    }
}

implementation("androidx.security:security-crypto:1.1.0-alpha06")

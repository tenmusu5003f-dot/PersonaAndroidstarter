// =====================================
// ğŸš€ Persona Android Starter - FastBoot Header
// =====================================

import android.content.Context
import kotlinx.coroutines.*
import android.util.Log

object FastBoot {
    private const val TAG = "FastBoot"

    suspend fun launch(ctx: Context): Boolean = coroutineScope {
        val start = System.currentTimeMillis()
        Log.i(TAG, "âš¡ Boot sequence start")

        // ä¸¦åˆ—å‡¦ç†ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆã™ã¹ã¦åŒæ™‚ã«èµ·å‹•ï¼‰
        val results = awaitAll(
            async { SignatureGuard.verifySelf(ctx) },
            async { TamperGuard.checkBuildFlags() },
            async { RootGuard.quickScan(ctx) },
            async { CryptoVault.warmup(ctx) },
            async { AssetGuard.verifyHashes(ctx) },
            async { NetGuard.pinSetup(ctx) },
            async { Prewarm.warmTTS(ctx) },
        )

        val ok = results.all { it }
        val time = System.currentTimeMillis() - start
        Log.i(TAG, "âš™ï¸ Boot complete: $ok ($time ms)")
        return@coroutineScope ok
    }
}

// security/BootOrchestrator.kt
package com.persona.androidstarter.security

import android.content.Context
import android.util.Log
import kotlinx.coroutines.*

/**
 * BootOrchestrator
 * èµ·å‹•æ™‚ã«è¤‡æ•°ã®ã€Œã‚¬ãƒ¼ãƒ‰ã€ã‚’ä¸¦åˆ—ã§å®Ÿè¡Œã—ã¦èµ·å‹•å¯å¦ã‚’åˆ¤å®šã™ã‚‹ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ã€‚
 * - å¿…é ˆã‚¬ãƒ¼ãƒ‰ï¼ä»»æ„ã‚¬ãƒ¼ãƒ‰ã®æ‰±ã„ã¯ã“ã“ã§æ‹¡å¼µå¯èƒ½
 */

object BootOrchestrator {
  private const val TAG = "BootOrchestrator"

  /**
   * runAll: èµ·å‹•æ™‚ã«å®‰å…¨ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿè¡Œã™ã‚‹ã€‚
   * - ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚„å€‹åˆ¥å¤±æ•—ã¯å‘¼ã³å‡ºã—å´ã§ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã•ã›ã‚‰ã‚Œã‚‹ã€‚
   * - æˆ»ã‚Šå€¤: true = å…¨éƒ¨OK (æ¨å¥¨å‡¦ç†)ã€false = ä½•ã‹å¤±æ•— (ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯)
   */
  suspend fun runAll(ctx: Context, timeoutMs: Long = 5_000): Boolean = coroutineScope {
    try {
      val deferreds = listOf(
        async { SignatureGuard.verifySelf(ctx) },         // ç½²åæ¤œè¨¼ï¼ˆå¿…é ˆï¼‰
        async { TamperGuard.checkBuildFlags(ctx) },      // æ”¹ã–ã‚“ãƒ•ãƒ©ã‚°æ¤œå‡ºï¼ˆå¿…é ˆï¼‰
        async { RootGuard.quickScan(ctx) },              // ãƒ«ãƒ¼ãƒˆç°¡æ˜“æ¤œçŸ¥ï¼ˆä»»æ„ï¼‰
        async { CryptoVault.ensureInit(ctx) },           // éµã‚¹ãƒˆã‚¢åˆæœŸåŒ–ï¼ˆå¿…é ˆï¼‰
        async { AssetGuard.verifyHashes(ctx) },         // ã‚¢ã‚»ãƒƒãƒˆãƒãƒƒã‚·ãƒ¥æ¤œè¨¼ï¼ˆæ¨å¥¨ï¼‰
        async { NetGuard.pinSetup(ctx) },               // è¨¼æ˜æ›¸ãƒ”ãƒ³ç­‰ï¼ˆä»»æ„ï¼‰
        async { TTSPrewarm.warm(ctx) }                  // TTSç­‰ãƒ—ãƒªã‚¦ã‚©ãƒ¼ãƒ ï¼ˆä»»æ„ï¼‰
      )

      // å…¨ä½“ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’å®ˆã‚‹
      withTimeout(timeoutMs) {
        val results = deferreds.awaitAll()
        // å…¨éƒ¨ true ãªã‚‰ trueã€‚å€‹åˆ¥ã« optional ã‚’è¨±å®¹ã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã¯ã“ã“ã‚’æ‹¡å¼µ
        return@coroutineScope results.all { it }
      }
    } catch (e: Exception) {
      Log.w(TAG, "boot checks failed: ${e.message}")
      return@coroutineScope false
    }
  }
}

// security/SessionManager.kt
package com.persona.androidstarter.security

import android.content.Context
import androidx.security.crypto.EncryptedSharedPreferences
import androidx.security.crypto.MasterKeys

/**
 * SessionManager
 * EncryptedSharedPreferences ã‚’ä½¿ã£ã¦ã‚»ãƒƒã‚·ãƒ§ãƒ³ï¼ˆç°¡æ˜“ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ï¼‰ã‚’ç®¡ç†ã™ã‚‹ã€‚
 * æ³¨æ„: æœ¬ç•ªã®èªè¨¼ã¯ã‚µãƒ¼ãƒå´ãƒã‚§ãƒƒã‚¯ã‚„ãƒˆãƒ¼ã‚¯ãƒ³é‹ç”¨ã‚’è¡Œã£ã¦ãã ã•ã„ã€‚
 */

class SessionManager(ctx: Context) {
  private val masterKeyAlias = MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC)
  private val prefs = EncryptedSharedPreferences.create(
    "persona.secure",
    masterKeyAlias,
    ctx,
    EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
    EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
  )

  fun isSignedIn(): Boolean = prefs.getBoolean("signed_in", false)
  fun signIn() = prefs.edit().putBoolean("signed_in", true).apply()
  fun signOut() = prefs.edit().clear().apply()

  // optional: store small metadata safely
  fun putString(key: String, value: String) = prefs.edit().putString(key, value).apply()
  fun getString(key: String, default: String? = null): String? = prefs.getString(key, default)
}

// security/AuthGate.kt
package com.persona.androidstarter.security

import androidx.navigation.NavController
import com.persona.androidstarter.nav.Routes

/**
 * AuthGate
 * NavController ã‚’é€šã—ã¦æœªãƒ­ã‚°ã‚¤ãƒ³ãªã‚‰ Login ã«å¯„ã›ã‚‹ç°¡æ˜“ã‚¬ãƒ¼ãƒ‰ã€‚
 * MainActivity å´ã§ session ã‚’ä½œæˆã—ã¦å‘¼ã¶æƒ³å®šã€‚
 */

object AuthGate {
  fun enforce(nav: NavController, session: SessionManager) {
    if (!session.isSignedIn()) {
      nav.navigate(Routes.Login) {
        popUpTo(Routes.Root) { inclusive = false }
        launchSingleTop = true
      }
    }
  }

// security/AssetGuard.kt
package com.persona.androidstarter.security

import android.content.Context
import android.util.Log
import org.json.JSONObject
import java.security.MessageDigest

/**
 * AssetGuard
 * assets/expected-hashes.json ã‚’å‚ç…§ã—ã¦ã‚¢ã‚»ãƒƒãƒˆã® SHA-256 ã‚’æ¤œè¨¼ã™ã‚‹ã€‚
 * expected-hashes.json ã¯ CI ç­‰ã§ç”Ÿæˆã—ã¦ assets ã«å…¥ã‚Œã¦ãŠãæƒ³å®šã€‚
 *
 * JSON å½¢å¼:
 * {
 *   "scripts/prologue.script": "abcdef1234...",
 *   "voices/aria.voice": "abcd..."
 * }
 */

object AssetGuard {
  private const val TAG = "AssetGuard"
  private const val EXPECTED_FILE = "expected-hashes.json"

  fun verifyHashes(ctx: Context): Boolean {
    return try {
      val expected = loadExpected(ctx) ?: run {
        Log.w(TAG, "no expected-hashes.json found â€” skipping asset guard")
        return true // ç”Ÿæˆã•ã‚Œã¦ãªã„å ´åˆã¯ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯è¨±å®¹
      }

      val assetManager = ctx.assets
      val keys = expected.keys()
      while (keys.hasNext()) {
        val name = keys.next()
        try {
          assetManager.open(name).use { ins ->
            val actual = sha256(ins)
            val expectedHash = expected.getString(name)
            if (!actual.equals(expectedHash, ignoreCase = true)) {
              Log.w(TAG, "asset hash mismatch: $name")
              return false
            }
          }
        } catch (e: Exception) {
          Log.w(TAG, "asset missing or unreadable: $name")
          return false
        }
      }
      true
    } catch (e: Throwable) {
      Log.e(TAG, "asset guard error: ${e.message}")
      false
    }
  }

  private fun loadExpected(ctx: Context): JSONObject? {
    return try {
      ctx.assets.open(EXPECTED_FILE).use { ins ->
        val s = ins.readBytes().toString(Charsets.UTF_8)
        JSONObject(s)
      }
    } catch (e: Exception) {
      null
    }
  }

  private fun sha256(ins: java.io.InputStream): String {
    val md = MessageDigest.getInstance("SHA-256")
    ins.use { input ->
      val buf = ByteArray(8192)
      var r: Int
      while (input.read(buf).also { r = it } > 0) md.update(buf, 0, r)
    }
    return md.digest().joinToString("") { "%02x".format(it) }
  }
}
}

// security/SignatureGuard.kt
package com.persona.androidstarter.security

import android.content.Context
import android.content.pm.PackageManager
import android.util.Log

/**
 * SignatureGuard
 * APK ã®ç½²åã‚’ç¢ºèªã™ã‚‹é››å½¢ã€‚
 * - ã“ã“ã§ã¯ã‚¢ãƒ—ãƒªè‡ªèº«ã®ç½²åã‚’å–å¾—ã—ã¦ç°¡æ˜“ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã†ã€‚
 * - æœ¬ç•ªã§ã¯å…¬çš„ãªéµã‚„é éš”ç½²åç…§åˆãªã©ã‚’å°å…¥ã—ã¦ãã ã•ã„ã€‚
 */

object SignatureGuard {
  private const val TAG = "SignatureGuard"

  fun verifySelf(ctx: Context): Boolean {
    return try {
      val packageInfo = ctx.packageManager.getPackageInfo(ctx.packageName, PackageManager.GET_SIGNING_CERTIFICATES)
      // Android 9+ ã§ã®ç½²åæƒ…å ±å–å¾—ã«åˆã‚ã›ã¦ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã†ï¼ˆç°¡æ˜“ï¼‰
      val signatures = packageInfo.signingInfo?.apkContentsSigners
      if (signatures == null || signatures.isEmpty()) {
        Log.w(TAG, "no signatures found")
        return false
      }
      // TODO: ã“ã“ã§æ—¢çŸ¥ã®ç½²åãƒãƒƒã‚·ãƒ¥ã¨æ¯”è¼ƒã™ã‚‹ç­‰ã®å®Ÿè£…ã‚’å…¥ã‚Œã‚‹
      true
    } catch (e: Exception) {
      Log.e(TAG, "signature verify failed: ${e.message}")
      false
    }
  }
}

// security/SignatureGuard.kt
package com.persona.androidstarter.security

import android.content.Context
import android.content.pm.PackageManager
import android.util.Log

/**
 * SignatureGuard
 * APK ã®ç½²åã‚’ç¢ºèªã™ã‚‹é››å½¢ã€‚
 * - ã“ã“ã§ã¯ã‚¢ãƒ—ãƒªè‡ªèº«ã®ç½²åã‚’å–å¾—ã—ã¦ç°¡æ˜“ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã†ã€‚
 * - æœ¬ç•ªã§ã¯å…¬çš„ãªéµã‚„é éš”ç½²åç…§åˆãªã©ã‚’å°å…¥ã—ã¦ãã ã•ã„ã€‚
 */

object SignatureGuard {
  private const val TAG = "SignatureGuard"

  fun verifySelf(ctx: Context): Boolean {
    return try {
      val packageInfo = ctx.packageManager.getPackageInfo(ctx.packageName, PackageManager.GET_SIGNING_CERTIFICATES)
      // Android 9+ ã§ã®ç½²åæƒ…å ±å–å¾—ã«åˆã‚ã›ã¦ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã†ï¼ˆç°¡æ˜“ï¼‰
      val signatures = packageInfo.signingInfo?.apkContentsSigners
      if (signatures == null || signatures.isEmpty()) {
        Log.w(TAG, "no signatures found")
        return false
      }
      // TODO: ã“ã“ã§æ—¢çŸ¥ã®ç½²åãƒãƒƒã‚·ãƒ¥ã¨æ¯”è¼ƒã™ã‚‹ç­‰ã®å®Ÿè£…ã‚’å…¥ã‚Œã‚‹
      true
    } catch (e: Exception) {
      Log.e(TAG, "signature verify failed: ${e.message}")
      false
    }
  }
}

// security/TamperGuard.kt
package com.persona.androidstarter.security

import android.content.Context
import android.util.Log

/**
 * TamperGuard
 * ãƒ“ãƒ«ãƒ‰ãƒ•ãƒ©ã‚°ã‚„æ¤œæŸ»ã®ç—•è·¡ã‚’ç¢ºèªã™ã‚‹ç°¡æ˜“ãƒã‚§ãƒƒã‚¯ã€‚
 * - ãƒ‡ãƒãƒƒã‚°ãƒ“ãƒ«ãƒ‰ã‹ã€æ”¹å¤‰ã•ã‚ŒãŸãƒªã‚½ãƒ¼ã‚¹ã®ç—•è·¡ã‚’æ¤œå‡ºã™ã‚‹ãŸã‚ã®å ´æ‰€
 */

object TamperGuard {
  private const val TAG = "TamperGuard"

  fun checkBuildFlags(ctx: Context): Boolean {
    return try {
      val isDebuggable = (ctx.applicationInfo.flags and android.content.pm.ApplicationInfo.FLAG_DEBUGGABLE) != 0
      if (isDebuggable) {
        Log.w(TAG, "app is debuggable â€” treat as potentially tampered")
        // é–‹ç™ºä¸­ã¯ true ã«ã—ã¦ãŠãã€‚ãƒªãƒªãƒ¼ã‚¹ã§ã¯ false ã‚’æœŸå¾…ã™ã‚‹
      }
      true
    } catch (e: Exception) {
      Log.e(TAG, "tamper guard error: ${e.message}")
      false
    }
  }
}

// security/RootGuard.kt
package com.persona.androidstarter.security

import android.content.Context
import android.util.Log
import java.io.File

/**
 * RootGuard
 * ãƒ«ãƒ¼ãƒˆåŒ–ã®ç°¡æ˜“æ¤œçŸ¥ï¼ˆ100%ã§ã¯ãªã„ï¼‰ã€‚
 * - ã‚ˆã‚Šå³å¯†ãªæ¤œçŸ¥ã¯ su ã®æŒ™å‹•ç¢ºèªã‚„ known root tool ã®ãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ ã™ã‚‹ã“ã¨
 */

object RootGuard {
  private const val TAG = "RootGuard"
  private val suPaths = listOf(
    "/system/bin/su", "/system/xbin/su", "/sbin/su", "/vendor/bin/su"
  )

  fun quickScan(ctx: Context): Boolean {
    return try {
      for (p in suPaths) {
        if (File(p).exists()) {
          Log.w(TAG, "su found at $p")
          return false
        }
      }
      // ã•ã‚‰ã« build tags ã§ã®åˆ¤å®šãªã©ã‚‚å¯èƒ½
      true
    } catch (e: Exception) {
      Log.e(TAG, "root guard error: ${e.message}")
      true
    }
  }
}

// security/CryptoVault.kt
package com.persona.androidstarter.security

import android.content.Context
import android.util.Log
import androidx.security.crypto.MasterKeys

/**
 * CryptoVault
 * éµã‚¹ãƒˆã‚¢åˆæœŸåŒ–ãªã©ã‚’ã¾ã¨ã‚ã‚‹å ´æ‰€ã€‚å®Ÿéš›ã®éµç®¡ç†ã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¦ä»¶ã§æ‹¡å¼µã—ã¦ãã ã•ã„ã€‚
 */

object CryptoVault {
  private const val TAG = "CryptoVault"

  fun ensureInit(ctx: Context): Boolean {
    return try {
      // MasterKeys.getOrCreate ã¯å†…éƒ¨ã§éµã‚’ä½œã‚‹ï¼ˆç«¯æœ«å®‰å…¨é ˜åŸŸã«ä¿ç®¡ã•ã‚Œã‚‹ï¼‰
      val master = MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC)
      Log.d(TAG, "master key ready: $master")
      true
    } catch (e: Exception) {
      Log.e(TAG, "crypto init failed: ${e.message}")
      false
    }
  }
}

// security/NetGuard.kt
package com.persona.androidstarter.security

import android.content.Context
import android.util.Log

/**
 * NetGuard
 * ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç³»ã®åˆæœŸåŒ–ï¼ˆè¨¼æ˜æ›¸ãƒ”ãƒ³ç­‰ï¼‰ã€‚ã“ã“ã¯ SDK / å®Ÿè£…ã«åˆã‚ã›ã¦ä¿®æ­£ã—ã¦ãã ã•ã„ã€‚
 */

object NetGuard {
  private const val TAG = "NetGuard"

  fun pinSetup(ctx: Context): Boolean {
    return try {
      // ã“ã“ã§ OkHttp ã®ãƒ”ãƒ³ãƒ‹ãƒ³ã‚°ã‚„ã‚«ã‚¹ã‚¿ãƒ  TrustManager ã‚’æ§‹æˆã™ã‚‹ãªã©ã®å‡¦ç†ã‚’è¡Œã†
      // ä»Šã¯ãƒ€ãƒŸãƒ¼ã§ true ã‚’è¿”ã™ï¼ˆä»»æ„ã®ãƒã‚§ãƒƒã‚¯ãªã®ã§å¤±æ•—ã§ã‚‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¯ï¼‰
      true
    } catch (e: Exception) {
      Log.e(TAG, "netguard error: ${e.message}")
      false
    }
  }
}

// security/TTSPrewarm.kt
package com.persona.androidstarter.security

import android.content.Context
import kotlinx.coroutines.*

/**
 * TTSPrewarm
 * å¤–éƒ¨ TTS ã®äº‹å‰èª­ã¿è¾¼ã¿ã‚’éåŒæœŸã§è¡Œã†ã€‚å¤±æ•—ã—ã¦ã‚‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã™ã‚‹ã€‚
 * å®Ÿè£…ã¯ä½¿ã£ã¦ã„ã‚‹ TTS SDK ã«åˆã‚ã›ã¦ä¸­èº«ã‚’æ›¸ãæ›ãˆã¦ãã ã•ã„ã€‚
 */

object TTSPrewarm {
  fun warm(ctx: Context) {
    GlobalScope.launch(Dispatchers.IO) {
      try {
        // ä¾‹: å¤–éƒ¨ SDK ã®åˆæœŸåŒ–ã‚„ãƒœã‚¤ã‚¹ä¸€è¦§å–å¾—ãªã©
        // ExternalTTS.init(ctx); ExternalTTS.preload("default")
      } catch (e: Exception) {
        // å¤±æ•—ã—ã¦ã‚‚èµ·å‹•ã‚’æ­¢ã‚ãªã„
      }
    }
  }
}

dependencies {
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.8.1")
    implementation("androidx.navigation:navigation-fragment-ktx:2.8.3")
    implementation("androidx.navigation:navigation-ui-ktx:2.8.3")
    implementation("androidx.security:security-crypto:1.1.0-alpha06")
}

<androidx.fragment.app.FragmentContainerView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/nav_host"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:name="androidx.navigation.fragment.NavHostFragment"
    app:navGraph="@navigation/nav_graph"
    app:defaultNavHost="true" />

<?xml version="1.0" encoding="utf-8"?>
<navigation xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/nav_graph"
    app:startDestination="@id/homeFragment">

    <fragment
        android:id="@+id/loginFragment"
        android:name="com.persona.androidstarter.entrance.LoginFragment"
        android:label="Login" />

    <fragment
        android:id="@+id/homeFragment"
        android:name="com.persona.androidstarter.feature.home.HomeFragment"
        android:label="Home" />
</navigation>

package com.persona.androidstarter.nav
object Routes {
    const val Root = "root"
    const val Login = "login"
    const val Home  = "home"
}

package com.persona.androidstarter

import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import androidx.navigation.findNavController
import androidx.navigation.fragment.NavHostFragment
import com.persona.androidstarter.security.*
import com.persona.androidstarter.nav.Routes
import kotlinx.coroutines.*

class MainActivity : AppCompatActivity() {
    private lateinit var session: SessionManager
    private val ui = MainScope()

    override fun onCreate(b: Bundle?) {
        super.onCreate(b)
        setContentView(R.layout.activity_main)
        session = SessionManager(this)
    }

    override fun onStart() {
        super.onStart()
        val nav = (supportFragmentManager
            .findFragmentById(R.id.nav_host) as NavHostFragment).navController

        // èµ·å‹•ã‚¬ãƒ¼ãƒ‰ã‚’ä¸¦åˆ—å®Ÿè¡Œ â†’ å¤±æ•—æ™‚ã¯ãƒ­ã‚°ã‚¤ãƒ³ã«å¯„ã›ã‚‹
        ui.launch {
            val ok = withContext(Dispatchers.IO) { BootOrchestrator.runAll(this@MainActivity) }
            if (!ok) {
                AuthGate.enforce(nav, session) // æœªã‚µã‚¤ãƒ³ã‚¤ãƒ³ or ã‚¬ãƒ¼ãƒ‰å¤±æ•— â†’ Login
            } else {
                if (session.isSignedIn()) {
                    nav.navigate(R.id.homeFragment)
                } else {
                    nav.navigate(R.id.loginFragment)
                }
            }
        }
    }

    override fun onDestroy() {
        ui.cancel()
        super.onDestroy()
    }
}

package com.persona.androidstarter.entrance

import android.os.Bundle
import android.view.*
import androidx.fragment.app.Fragment
import com.persona.androidstarter.security.SessionManager
import androidx.navigation.fragment.findNavController
import com.persona.androidstarter.R

class LoginFragment : Fragment() {
    override fun onCreateView(i: LayoutInflater, c: ViewGroup?, s: Bundle?): View {
        val v = View.inflate(requireContext(), android.R.layout.simple_list_item_1, null)
        v.setOnClickListener {
            SessionManager(requireContext()).signIn()
            findNavController().navigate(R.id.homeFragment)
        }
        return v
    }
}

package com.persona.androidstarter.feature.home

import android.os.Bundle
import android.view.*
import androidx.fragment.app.Fragment
import android.widget.TextView

class HomeFragment : Fragment() {
    override fun onCreateView(i: LayoutInflater, c: ViewGroup?, s: Bundle?): View {
        return TextView(requireContext()).apply { text = "ğŸš€ Home" }
    }
}

{
  "scripts/prologue.script": "deadbeef",
  "voices/aria.voice": "deadbeef"
}

<application
    android:usesCleartextTraffic="false">
    <!-- å¿…è¦ã«å¿œã˜ã¦ networkSecurityConfig ã‚’è¨­å®š -->
</application>

dependencies {
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.8.1")
    implementation("androidx.navigation:navigation-fragment-ktx:2.8.3")
    implementation("androidx.navigation:navigation-ui-ktx:2.8.3")
    implementation("androidx.security:security-crypto:1.1.0-alpha06")
}

package com.persona.androidstarter.security

import android.content.Context
import android.content.pm.PackageManager
import android.util.Log
import androidx.security.crypto.EncryptedSharedPreferences
import androidx.security.crypto.MasterKeys
import kotlinx.coroutines.*
import org.json.JSONObject
import java.io.File
import java.security.MessageDigest

/** ===========================
 *  ğŸš€ FastBoot + Guards ä¸€å¼
 *  =========================== */

object FastBoot {
    private const val TAG = "FastBoot"
    suspend fun launch(ctx: Context, timeoutMs: Long = 5_000): Boolean = coroutineScope {
        try {
            val t0 = System.currentTimeMillis()
            val results = withTimeout(timeoutMs) {
                awaitAll(
                    async { SignatureGuard.verifySelf(ctx) },     // å¿…é ˆ
                    async { TamperGuard.checkBuildFlags(ctx) },   // å¿…é ˆ(é–‹ç™ºä¸­ã¯å¸¸ã«true)
                    async { RootGuard.quickScan(ctx) },           // ä»»æ„
                    async { CryptoVault.ensureInit(ctx) },        // å¿…é ˆ
                    async { AssetGuard.verifyHashes(ctx) },       // æ¨å¥¨
                    async { NetGuard.pinSetup(ctx) },             // ä»»æ„
                    async { TTSPrewarm.warm(ctx); true }          // ä»»æ„ï¼ˆå¤±æ•—ã—ã¦ã‚‚ç¶šè¡Œï¼‰
                )
            }
            val ok = results.all { it }
            Log.i(TAG, "Boot complete=$ok in ${System.currentTimeMillis()-t0} ms")
            ok
        } catch (e: Exception) {
            Log.w(TAG, "boot error: ${e.message}")
            false
        }
    }
}

/** ã‚»ãƒƒã‚·ãƒ§ãƒ³ï¼ˆæš—å·åŒ–Preferencesï¼‰ */
class SessionManager(ctx: Context) {
    private val master = MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC)
    private val pref = EncryptedSharedPreferences.create(
        "persona.secure", master, ctx,
        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
    )
    fun isSignedIn(): Boolean = pref.getBoolean("signed_in", false)
    fun signIn() = pref.edit().putBoolean("signed_in", true).apply()
    fun signOut() = pref.edit().clear().apply()
}

/** æœªãƒ­ã‚°ã‚¤ãƒ³ãªã‚‰Loginã¸å¯„ã›ã‚‹ */
object AuthGate {
    fun enforce(nav: androidx.navigation.NavController, session: SessionManager) {
        if (!session.isSignedIn()) {
            nav.navigate(com.persona.androidstarter.R.id.loginFragment) {
                popUpTo(com.persona.androidstarter.R.id.homeFragment) { inclusive = false }
                launchSingleTop = true
            }
        }
    }
}

/** ç½²åãƒã‚§ãƒƒã‚¯ï¼ˆé››å½¢ï¼‰ */
object SignatureGuard {
    private const val TAG = "SignatureGuard"
    fun verifySelf(ctx: Context): Boolean = try {
        val info = ctx.packageManager.getPackageInfo(
            ctx.packageName, PackageManager.GET_SIGNING_CERTIFICATES
        )
        val ok = !info.signingInfo?.apkContentsSigners.isNullOrEmpty()
        if (!ok) Log.w(TAG, "no signatures")
        ok
    } catch (e: Exception) { Log.e(TAG,"${e.message}"); false }
}

/** ãƒ‡ãƒãƒƒã‚°/æ”¹å¤‰ãƒ•ãƒ©ã‚°ï¼ˆé››å½¢ï¼‰ */
object TamperGuard {
    fun checkBuildFlags(ctx: Context): Boolean = try {
        // é–‹ç™ºä¸­ã¯ true ã§é€šã™ã€‚ãƒªãƒªãƒ¼ã‚¹ã§ã¯å³æ ¼ã«ã€‚
        true
    } catch (e: Exception) { false }
}

/** ãƒ«ãƒ¼ãƒˆç°¡æ˜“æ¤œçŸ¥ */
object RootGuard {
    private val suPaths = listOf("/system/bin/su","/system/xbin/su","/sbin/su","/vendor/bin/su")
    fun quickScan(@Suppress("UNUSED_PARAMETER") ctx: Context): Boolean = try {
        suPaths.none { File(it).exists() }
    } catch (_: Exception) { true }
}

/** éµåˆæœŸåŒ– */
object CryptoVault {
    fun ensureInit(@Suppress("UNUSED_PARAMETER") ctx: Context): Boolean = try {
        MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC); true
    } catch (_: Exception) { false }
}

/** ã‚¢ã‚»ãƒƒãƒˆãƒãƒƒã‚·ãƒ¥æ¤œè¨¼ï¼ˆassets/expected-hashes.json ã‚’å‚ç…§ãƒ»æœªé…ç½®ã¯é€šéï¼‰ */
object AssetGuard {
    private fun loadExpected(ctx: Context): JSONObject? = try {
        ctx.assets.open("expected-hashes.json").use { ins ->
            JSONObject(ins.readBytes().toString(Charsets.UTF_8))
        }
    } catch (_: Exception) { null }

    fun verifyHashes(ctx: Context): Boolean = try {
        val expected = loadExpected(ctx) ?: return true
        val am = ctx.assets
        val keys = expected.keys()
        while (keys.hasNext()) {
            val name = keys.next()
            am.open(name).use { ins ->
                val actual = sha256(ins)
                val want = expected.getString(name)
                if (!actual.equals(want, true)) return false
            }
        }
        true
    } catch (_: Exception) { false }

    private fun sha256(ins: java.io.InputStream): String {
        val md = MessageDigest.getInstance("SHA-256")
        val buf = ByteArray(8192); var r: Int
        while (ins.read(buf).also { r = it } > 0) md.update(buf, 0, r)
        return md.digest().joinToString("") { "%02x".format(it) }
    }
}

/** ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åˆæœŸåŒ–ï¼ˆãƒ”ãƒ³ãƒ‹ãƒ³ã‚°ç­‰ã‚’å¾Œã§å®Ÿè£…ï¼‰ */
object NetGuard { fun pinSetup(@Suppress("UNUSED_PARAMETER") ctx: Context) = true }

/** TTSãƒ—ãƒªã‚¦ã‚©ãƒ¼ãƒ ï¼ˆSDKã«åˆã‚ã›ã¦ä¸­èº«ã‚’å…¥ã‚Œã¦ã­ï¼‰ */
object TTSPrewarm { fun warm(@Suppress("UNUSED_PARAMETER") ctx: Context) { /* no-op */ } }

class MainActivity : AppCompatActivity() {
    private lateinit var session: SessionManager
    private val ui = MainScope()

    override fun onCreate(b: Bundle?) {
        super.onCreate(b)
        setContentView(R.layout.activity_main)
        session = SessionManager(this)
    }

    override fun onStart() {
        super.onStart()
        val nav = (supportFragmentManager
            .findFragmentById(R.id.nav_host) as NavHostFragment).navController

        ui.launch {
            val ok = withContext(Dispatchers.IO) { FastBoot.launch(this@MainActivity) }
            if (!ok) AuthGate.enforce(nav, session)
            else if (session.isSignedIn()) nav.navigate(R.id.homeFragment)
                 else nav.navigate(R.id.loginFragment)
        }
    }

    override fun onDestroy() { ui.cancel(); super.onDestroy() }
}

{
  "scripts/prologue.script": "deadbeef"
}

object NetGuard {
    private const val TAG = "NetGuard"
    lateinit var client: okhttp3.OkHttpClient

    fun pinSetup(ctx: Context): Boolean = try {
        val host = "api.example.com" // â†ã‚ãªãŸã®APIãƒ‰ãƒ¡ã‚¤ãƒ³
        val pins = listOf(
            // openssl x509 -pubkey -noout -in cert.pem | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | base64
            "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
        )
        val pinner = okhttp3.CertificatePinner.Builder().apply {
            pins.forEach { add(host, it) }
        }.build()
        client = okhttp3.OkHttpClient.Builder()
            .certificatePinner(pinner)
            .build()
        Log.i(TAG, "NetGuard ready for $host")
        true
    } catch (e: Exception) {
        Log.e(TAG, "NetGuard error: ${e.message}")
        false
    }

    fun get(url: String): String? = try {
        val req = okhttp3.Request.Builder().url(url).build()
        client.newCall(req).execute().use { it.body?.string() }
    } catch (e: Exception) {
        Log.e(TAG, "GET failed: ${e.message}")
        null
    }
}

object TTSPrewarm {
    private const val TAG = "TTSPrewarm"
    private var tts: android.speech.tts.TextToSpeech? = null

    fun warm(ctx: Context): Boolean {
        return try {
            tts = android.speech.tts.TextToSpeech(ctx) {
                if (it == android.speech.tts.TextToSpeech.SUCCESS) {
                    tts?.language = java.util.Locale.JAPANESE
                    tts?.speak("èµ·å‹•ãƒã‚§ãƒƒã‚¯å®Œäº†ã§ã™", android.speech.tts.TextToSpeech.QUEUE_FLUSH, null, "boot")
                    Log.i(TAG, "TTS ready")
                } else Log.w(TAG, "TTS init failed: $it")
            }
            true
        } catch (e: Exception) {
            Log.e(TAG, "TTS warm error: ${e.message}")
            false
        }
    }

    fun say(text: String) {
        tts?.speak(text, android.speech.tts.TextToSpeech.QUEUE_FLUSH, null, "say")
    }

    fun release() { tts?.shutdown() }
}

object CryptoVault {
    private const val TAG = "CryptoVault"
    private val charset = Charsets.UTF_8

    fun ensureInit(ctx: Context): Boolean = try {
        MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC)
        Log.i(TAG, "Crypto ready")
        true
    } catch (e: Exception) {
        Log.e(TAG, "Crypto init failed: ${e.message}")
        false
    }

    fun encrypt(text: String, key: SecretKeySpec): String {
        val cipher = javax.crypto.Cipher.getInstance("AES/GCM/NoPadding")
        cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, key)
        val iv = cipher.iv
        val enc = cipher.doFinal(text.toByteArray(charset))
        return android.util.Base64.encodeToString(iv + enc, android.util.Base64.NO_WRAP)
    }

    fun decrypt(base64: String, key: SecretKeySpec): String {
        val all = android.util.Base64.decode(base64, android.util.Base64.NO_WRAP)
        val iv = all.copyOfRange(0, 12)
        val body = all.copyOfRange(12, all.size)
        val cipher = javax.crypto.Cipher.getInstance("AES/GCM/NoPadding")
        cipher.init(javax.crypto.Cipher.DECRYPT_MODE, key, javax.crypto.spec.GCMParameterSpec(128, iv))
        return String(cipher.doFinal(body), charset)
    }
}

object CryptoVault {
    private const val TAG = "CryptoVault"
    private val charset = Charsets.UTF_8

    fun ensureInit(ctx: Context): Boolean = try {
        MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC)
        Log.i(TAG, "Crypto ready")
        true
    } catch (e: Exception) {
        Log.e(TAG, "Crypto init failed: ${e.message}")
        false
    }

    fun encrypt(text: String, key: SecretKeySpec): String {
        val cipher = javax.crypto.Cipher.getInstance("AES/GCM/NoPadding")
        cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, key)
        val iv = cipher.iv
        val enc = cipher.doFinal(text.toByteArray(charset))
        return android.util.Base64.encodeToString(iv + enc, android.util.Base64.NO_WRAP)
    }

    fun decrypt(base64: String, key: SecretKeySpec): String {
        val all = android.util.Base64.decode(base64, android.util.Base64.NO_WRAP)
        val iv = all.copyOfRange(0, 12)
        val body = all.copyOfRange(12, all.size)
        val cipher = javax.crypto.Cipher.getInstance("AES/GCM/NoPadding")
        cipher.init(javax.crypto.Cipher.DECRYPT_MODE, key, javax.crypto.spec.GCMParameterSpec(128, iv))
        return String(cipher.doFinal(body), charset)
    }
}

override fun onStart() {
    super.onStart()
    val nav = (supportFragmentManager
        .findFragmentById(R.id.nav_host) as NavHostFragment).navController

    ui.launch {
        val ok = withContext(Dispatchers.IO) { FastBoot.launch(this@MainActivity) }
        if (!ok) {
            TTSPrewarm.say("ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯ã«å¤±æ•—ã—ã¾ã—ãŸ")
            AuthGate.enforce(nav, session)
        } else {
            TTSPrewarm.say("ã™ã¹ã¦ã®ã‚·ã‚¹ãƒ†ãƒ ãŒæ­£å¸¸ã§ã™")
            if (session.isSignedIn()) nav.navigate(R.id.homeFragment)
            else nav.navigate(R.id.loginFragment)
        }
    }
}
